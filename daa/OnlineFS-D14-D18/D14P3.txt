/*
In Marketing Job, each agent will mentor atmost two sub-agents. 
At the end, all mentor agents and sub agents, will be treated as agents only.

Now, you are given the sales data of two months as a tree, tree contains the 
count of the items sold by each agent, few agents might join the job and 
few might left the job.

You are given the sales data as month-1 and month-2.
Your task is to find get the combined report of two months data.

Implement the class Solution:
   1. public BinaryTreeNode combinedReport(BinaryTreeNode root1, BinaryTreeNode root2): 
    returns the root node of the combined data.

NOTE:
	- In the tree '-1', indicates no sales(null).

Input Format:
-------------
Line-1: space separated integers, sales data of month-1

Output Format:
--------------
Print an integer, second top agent based on rank.


Sample Input-1:
---------------
2 5 2 -1 -1 -1 4
1 2 3 4 5 -1 -1

Sample Output-1:
----------------
3 7 5 4 5 -1 4


Sample Input-2:
---------------
1 2 3 4 -1 -1 -1
1 -1 -1

Sample Output-2:
----------------
2 2 3 4 -1 -1 -1

NOTE: if the level contains only -1's or null nodes, the level has to be ignored.


=== testcases ===
case =1
input =1 2 3 4 -1 -1 -1
1 -1 -1
output =2 2 3 4 -1 -1 -1

case =2
input =2 5 2 -1 -1 -1 4
1 2 3 4 5 -1 -1
output =3 7 5 4 5 -1 4

case =3
input =1 3 2 5
2 1 3 -1 4 -1 7
output =3 4 5 5 4 -1 7

case =4
input =11 99 88 77 -1 -1 66 55 -1 -1 -1 -1 -1 -1 44
11 99 88 77 -1 -1 66 55 -1 -1 -1 -1 -1 -1 44 33 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 22
output =22 198 176 154 -1 -1 132 110 -1 -1 -1 -1 -1 -1 88 33 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 22

case =5
input =11 99 88 77 -1 -1 66 55 -1 -1 -1 -1 -1 -1 44
7 1 4 6 -1 5 3 -1 -1 -1 -1 -1 2
output =18 100 92 83 -1 5 69 55 -1 -1 -1 -1 2 44

case =6
input =7 1 4 6 -1 5 3 -1 -1 -1 -1 -1 2
2 1 3 -1 4 -1 7 -1 -1 1 3 -1 -1 2 5
output =9 2 7 6 4 5 10 -1 -1 1 3 -1 2 2 5

case =7
input =1 3 5 3 -1 -1 9 8 -1 -1 -1 -1 -1 -1 5 10 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 13
11 99 88 77 -1 -1 66 55 -1 -1 -1 -1 -1 -1 44 33 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 22
output =12 102 93 80 -1 -1 75 63 -1 -1 -1 -1 -1 -1 49 43 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 13 22

case =8
input =1 10 4 3 -1 7 9 12 8 -1 -1 6 2 9 13
1 2 4 3 5 6 9 12 8 14 11 6 2 9 13
output =2 12 8 6 5 13 18 24 16 14 11 12 4 18 26


*/

import java.util.*;

class BinaryTreeNode{
	public int data; 
	public BinaryTreeNode left, right; 
	public BinaryTreeNode(int data){
		this.data = data; 
		left = null; 
		right = null; 
	}
}


public class MergeTrees{
    BinaryTreeNode root;
	
	public MergeTrees() { root = null; }
	
    void printLevelOrder()
    {
        int h = height(root);
        int i;
        for (i = 1; i <= h; i++)
            printCurrentLevel(root, i);
    }
 
    int height(BinaryTreeNode root)
    {
        if (root == null || root.data==-1)
            return 0;
        else {
            int lheight = height(root.left);
            int rheight = height(root.right);
 
            if (lheight > rheight)
                return (lheight + 1);
            else
                return (rheight + 1);
        }
    }
 
    void printCurrentLevel(BinaryTreeNode root, int level)
    {
        if (root == null)
            return;
        if (level == 1)
            System.out.print(root.data + " ");
        else if (level > 1) {
            printCurrentLevel(root.left, level - 1);
            printCurrentLevel(root.right, level - 1);
        }
    }
    
    void insert(BinaryTreeNode temp, int key)
    {
 
        if (temp == null) {
            temp = new BinaryTreeNode(key);
            return;
        }
        Queue<BinaryTreeNode> q = new LinkedList<BinaryTreeNode>();
        q.add(temp);
 
        // Do level order traversal until we find
        // an empty place.
        while (!q.isEmpty()) {
            temp = q.peek();
            q.remove();
 
            if (temp.left == null) {
                temp.left = new BinaryTreeNode(key);
                break;
            }
            else
                q.add(temp.left);
 
            if (temp.right == null) {
                temp.right = new BinaryTreeNode(key);
                break;
            }
            else
                q.add(temp.right);
        }
    }
	public static void main(String args[])
	{
		Scanner sc=new Scanner(System.in);
		MergeTrees m1=new MergeTrees();
		MergeTrees m2=new MergeTrees();
		MergeTrees m=new MergeTrees();
		Solution sol= new Solution();
		
		String str1[]=sc.nextLine().split(" ");
		String str2[]=sc.nextLine().split(" ");
		m1.root=new BinaryTreeNode(Integer.parseInt(str1[0]));
		m2.root=new BinaryTreeNode(Integer.parseInt(str2[0]));
		
		for(int i=1; i<str1.length; i++)
			m1.insert(m1.root,Integer.parseInt(str1[i]));
		for(int i=1; i<str2.length; i++)
			m2.insert(m2.root,Integer.parseInt(str2[i]));
			
		m.root=sol.combinedReport(m1.root,m2.root);
		m.printLevelOrder();
	}
}

class Solution{
    public BinaryTreeNode combinedReport(BinaryTreeNode r1, BinaryTreeNode r2){
        if(r1==null || r1.data==-1){
            return r2;
        }
        if(r2==null || r2.data==-1){
            return r1;
        }
        r1.data+=r2.data;
        r1.left=combinedReport(r1.left,r2.left);
        r1.right=combinedReport(r1.right,r2.right);
        return r1;
    }
}
